# Production Environment Configuration for High Concurrency
# Copy this file to .env and adjust values for your environment

# =============================================================================
# DATABASE CONFIGURATION (PostgreSQL)
# =============================================================================
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=ecommerce_prod
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password_here

# =============================================================================
# DATABASE CONNECTION POOL (Optimized for 400 concurrent requests)
# =============================================================================
# With 4 workers: 50 pool + 100 overflow = 150 connections per worker
# Total capacity: 4 workers × 150 = 600 database connections
DB_POOL_SIZE=50
DB_MAX_OVERFLOW=100
DB_POOL_TIMEOUT=10
DB_POOL_RECYCLE=3600

# =============================================================================
# UVICORN SERVER CONFIGURATION
# =============================================================================
# Number of worker processes (recommended: 2 × CPU_cores + 1)
# For 4 cores: 9 workers, but we cap at 4-8 for optimal performance
UVICORN_WORKERS=4

# Server host and port
API_HOST=0.0.0.0
API_PORT=8000

# Reload on code changes (NEVER enable in production!)
RELOAD=false

# =============================================================================
# PERFORMANCE TUNING
# =============================================================================
# Maximum number of pending connections in the backlog queue
# Higher values allow more requests to wait during traffic spikes
BACKLOG=2048

# Keep-alive timeout in seconds
# Lower values free up connections faster
TIMEOUT_KEEP_ALIVE=5

# Maximum number of concurrent connections
# Set higher than expected peak to avoid rejecting requests
LIMIT_CONCURRENCY=1000

# Maximum requests per worker before restart (prevents memory leaks)
# Worker will restart after handling this many requests
LIMIT_MAX_REQUESTS=10000

# =============================================================================
# POSTGRESQL SERVER CONFIGURATION (Adjust in postgresql.conf)
# =============================================================================
# Ensure PostgreSQL can handle the connection pool:
# max_connections = (UVICORN_WORKERS × (DB_POOL_SIZE + DB_MAX_OVERFLOW)) + buffer
# Example: (4 × 150) + 50 = 650 connections
#
# Recommended postgresql.conf settings:
# max_connections = 700
# shared_buffers = 256MB (or 25% of RAM)
# effective_cache_size = 1GB (or 50% of RAM)
# work_mem = 16MB
# maintenance_work_mem = 128MB
# checkpoint_completion_target = 0.9
# wal_buffers = 16MB
# default_statistics_target = 100
# random_page_cost = 1.1
# effective_io_concurrency = 200

# =============================================================================
# REDIS CACHE CONFIGURATION
# =============================================================================
# Redis server connection
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=your_strong_redis_password_here

# Redis connection pool
REDIS_MAX_CONNECTIONS=50

# Enable/disable caching (set to 'false' to disable without removing Redis)
REDIS_ENABLED=true

# Default cache TTL in seconds (300 = 5 minutes)
# Products: 5 minutes, Categories: 1 hour (configured in services)
REDIS_CACHE_TTL=300

# =============================================================================
# RATE LIMITING
# =============================================================================
# Enable/disable rate limiting
RATE_LIMIT_ENABLED=true

# Maximum requests per time window per IP address
RATE_LIMIT_CALLS=100

# Time window in seconds
RATE_LIMIT_PERIOD=60

# =============================================================================
# MONITORING & LOGGING
# =============================================================================
LOG_LEVEL=info
ACCESS_LOG=true

# =============================================================================
# NOTES FOR PRODUCTION DEPLOYMENT
# =============================================================================
# 1. Always use a strong password for POSTGRES_PASSWORD
# 2. Run behind a reverse proxy (Nginx/Traefik) for SSL/TLS
# 3. Enable firewall rules to restrict database access
# 4. Use connection pooling at application level (already configured)
# 5. Monitor database connections: SELECT count(*) FROM pg_stat_activity;
# 6. Set up health check endpoints for load balancer
# 7. Configure log rotation to prevent disk space issues
# 8. Use environment-specific .env files (.env.production, .env.staging)